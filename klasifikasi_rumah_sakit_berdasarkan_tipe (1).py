# -*- coding: utf-8 -*-
"""Klasifikasi Rumah Sakit berdasarkan Tipe.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NuMVbSgNdRGkAiS36YNrzGTOiDE704_w

# **Import Package**
"""

# Commented out IPython magic to ensure Python compatibility.
# Pustaka untuk mengolah dan visualisasi data
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
# %matplotlib inline
import seaborn as sns

# Pustaka keperluan model
from imblearn.over_sampling import SMOTE
from sklearn.preprocessing import LabelEncoder
from collections import Counter
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, RobustScaler, MinMaxScaler
from sklearn.decomposition import PCA
from sklearn.neighbors import KNeighborsClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, confusion_matrix, classification_report

# Mengabaikan peringatan
import warnings
warnings.filterwarnings('ignore')

"""# **Data Loading**"""

#Menampilkan dataset
import pandas as pd
nel = pd.read_csv('Hospital_Indonesia_datasets.csv', sep=';')
nel

"""# **EDA (Exploratory Data Analysis)**"""

#Menampilkan info dataset
nel.info()

"""Ringkasan dataframe:
*   Data memiliki 11 kolom dan 3155 baris
*   Membuang kolom id karena tidak diperlukan

# **Data Cleaning**
"""

#Membuang kolom id
nel = nel.drop(columns=['id', 'nama','alamat'])

#Periksa jumlah kelas pada kolom kelas
nel['kelas'].value_counts()

#Menampilkan visualisasi Distribusi Kelas Rumah Sakit di Indonesia
plt.figure(figsize=(8,5))
sns.countplot(data=nel, x='kelas', order=nel['kelas'].value_counts().index, palette='pastel')
plt.title('Distribusi Kelas Rumah Sakit di Indonesia')
plt.xlabel('Kelas Rumah Sakit')
plt.ylabel('Jumlah')
plt.show()

#Simpan hanya data dengan kelas A, B, C, atau D
nel = nel[nel['kelas'].isin(['A', 'B', 'C', 'D'])]

#Periksa apakah label kelas sudah tersisa 4 kelas
nel['kelas'].value_counts()

#Periksa info dataset terbaru
nel.info()

#Periksa missing values
nel.isnull().sum()

#Periksa duplikat
nel.duplicated().sum()

#Periksa outlier pada fitur numerik
numerik = ['total_tempat_tidur', 'total_layanan', 'total_tenaga_kerja']

# Boxplot untuk masing-masing fitur numerik
plt.figure(figsize=(15, 5))
for i, kolom in enumerate(numerik):
    plt.subplot(1, 3, i + 1)
    sns.boxplot(x=nel[kolom])
    plt.title(f'Boxplot {kolom}')
plt.tight_layout()
plt.show()

#Menangani outlier
nel_clean = nel.copy()

# Daftar fitur numerik yang akan dicek
fitur_numerik = ['total_tempat_tidur', 'total_layanan', 'total_tenaga_kerja']

# Hitung IQR untuk setiap fitur numerik
Q1 = nel_clean[fitur_numerik].quantile(0.25)
Q3 = nel_clean[fitur_numerik].quantile(0.75)
IQR = Q3 - Q1

# Buang baris yang memiliki outlier pada salah satu fitur numerik
nel_clean = nel_clean[~((nel_clean[fitur_numerik] < (Q1 - 1.5 * IQR)) |
                        (nel_clean[fitur_numerik] > (Q3 + 1.5 * IQR))).any(axis=1)]

# Cek hasil
print(f"Jumlah data setelah membuang outlier: {nel_clean.shape[0]}")

#Periksa ukuran data setelah dibersihkan
nel_clean.shape

#Menampilkan statistik data
nel_clean.describe()

"""Setelah melakukan penanganan outlier dataset kita menjadi 2688 baris dan 11 kolom.

Berikut adalah insight yang diperoleh berdasarkan statistik deskriptif:
*   Jumlah Tempat Tidur di rumah sakit sangat bervariasi, mulai dari 0 hingga 306 unit. Rata-rata rumah sakit memiliki sekitar 99 tempat tidur, dengan kuartil atas (75%) berada di 125 tempat tidur, menunjukkan banyak rumah sakit kapasitas menengah ke bawah.

*   Jumlah Layanan yang tersedia berkisar antara 1 hingga 92. Nilai tengah (median) adalah 29 layanan, dengan rata-rata 33 layanan. Ini menunjukkan adanya rumah sakit yang sangat kecil dengan layanan terbatas, hingga yang sangat lengkap.

*   Jumlah Tenaga Kerja memiliki distribusi sangat lebar, dari 0 hingga 761 orang. Rata-ratanya adalah sekitar 179 tenaga kerja per rumah sakit, dengan standar deviasi yang tinggi (165), menandakan variasi yang besar antar rumah sakit.

# **Univariate**
"""

# List fitur numerik
numerik = ['total_tempat_tidur', 'total_layanan', 'total_tenaga_kerja']

# Buat subplots: 1 baris, 3 kolom
fig, axes = plt.subplots(1, 3, figsize=(18, 5))

# Looping setiap kolom dan plotting ke masing-masing axes
for i, col in enumerate(numerik):
    sns.histplot(nel_clean[col], kde=True, color='skyblue', ax=axes[i])
    axes[i].set_title(f'Distribusi {col}')
    axes[i].set_xlabel(col)
    axes[i].set_ylabel('Frekuensi')

plt.tight_layout()
plt.show()

"""*   Distribusi total_tempat_tidur: Distribusi ini bersifat multimodal dengan beberapa puncak yang jelas terlihat, dan miring ke kanan (positively skewed). Ini menunjukkan bahwa mayoritas rumah sakit memiliki jumlah tempat tidur yang rendah hingga sedang, sementara hanya sebagian kecil yang memiliki jumlah tempat tidur sangat tinggi (hingga 300), yang menarik ekor distribusi ke kanan. Kondisi ini mungkin mencerminkan perbedaan kapasitas antara rumah sakit kecil dan rumah sakit besar atau pusat rujukan nasional.

*   Distribusi total_layanan: Distribusi total layanan tampak miring ke kanan (positively skewed). Sebagian besar rumah sakit menawarkan layanan dalam jumlah sedang (sekitar 20–40), sementara terdapat beberapa rumah sakit dengan jumlah layanan yang jauh lebih banyak, yang menyebabkan distribusi memiliki ekor panjang di sebelah kanan. Hal ini bisa jadi mencerminkan rumah sakit besar atau pusat kesehatan khusus dengan banyak layanan spesialis.

*  Distribusi total_tenaga_kerja: Distribusi ini sangat miring ke kanan (highly positively skewed). Mayoritas rumah sakit memiliki jumlah tenaga kerja yang relatif kecil hingga sedang, namun ada segelintir rumah sakit dengan jumlah tenaga kerja sangat besar (hingga lebih dari 700 orang). Nilai ekstrem ini mencerminkan keberadaan rumah sakit besar dengan skala operasional yang luas dan tenaga medis yang banyak.




"""

plt.figure(figsize=(12, 8))
sns.countplot(y='propinsi', data=nel_clean, order=nel_clean['propinsi'].value_counts().index, palette='viridis')
plt.title('Distribusi Rumah Sakit per Provinsi')
plt.xlabel('Jumlah Rumah Sakit')
plt.ylabel('Provinsi')
plt.tight_layout()
plt.show()

"""## Insight Distribusi Rumah Sakit per Provinsi di Indonesia
1. Pola Konsentrasi Rumah Sakit

* Provinsi Jawa Timur, Jawa Barat, dan Jawa Tengah mendominasi jumlah rumah sakit di Indonesia. Ketiga provinsi ini memiliki jumlah rumah sakit lebih dari 300, menunjukkan konsentrasi layanan kesehatan yang tinggi di Pulau Jawa.
* Sumatera Utara dan DKI Jakarta juga memiliki jumlah rumah sakit yang tinggi, mengindikasikan tingginya kebutuhan layanan kesehatan di daerah dengan kepadatan penduduk yang besar.

2. Ketimpangan Distribusi Antar Wilayah
* Provinsi-provinsi di bagian timur Indonesia seperti Papua, Papua Barat, Papua Pegunungan, dan Papua Selatan memiliki jumlah rumah sakit yang sangat sedikit (kurang dari 20). Hal ini menunjukkan adanya kesenjangan akses layanan kesehatan antar wilayah barat dan timur Indonesia.
* Provinsi seperti Nusa Tenggara Timur, Maluku, dan Sulawesi Barat juga memiliki jumlah rumah sakit yang relatif rendah dibandingkan dengan provinsi di Jawa dan Sumatera.

3. Provinsi dengan Jumlah Rumah Sakit Terendah
* Provinsi seperti Papua Pegunungan, Papua Selatan, dan Papua Barat Daya tercatat sebagai wilayah dengan jumlah rumah sakit paling sedikit di Indonesia, menandakan potensi masalah dalam aksesibilitas layanan kesehatan dasar di wilayah ini.

4. Indikasi Perluasan Fasilitas
* Wilayah-wilayah dengan jumlah rumah sakit terbatas kemungkinan memerlukan intervensi kebijakan berupa pembangunan rumah sakit baru atau distribusi ulang tenaga kesehatan.
* Pemerataan fasilitas kesehatan ini sangat krusial untuk memastikan keadilan sosial dan pemerataan pelayanan publik di seluruh wilayah Indonesia.
"""

#Menampilkan jumlah kab/kota yang memiliki rumah sakit
nel_clean['kab'].nunique()

"""# **Multivariate**"""

# Menampilkan kelas rumah sakit pada provinsi dengan jumlah kela A,B,C,D
plt.figure(figsize=(16, 10))
sns.countplot(x=nel_clean['propinsi'], hue=nel_clean['kelas'],  data=nel_clean)
plt.xticks(rotation=45, ha='right')
plt.title('kelas rumah sakit pada provinsi')
plt.ylabel('Jumlah')
plt.show()

"""## Insight Distribusi Kelas Rumah Sakit per Provinsi
1. Dominasi Kelas C secara Nasional

* Kelas C secara konsisten mendominasi di hampir semua provinsi, terutama di
Jawa Timur (sekitar 240 RS kelas C) &
Jawa Barat, Jawa Tengah, dan DKI Jakarta
* Ini mengindikasikan bahwa rumah sakit dengan fasilitas tingkat menengah adalah yang paling umum secara nasional.

2. Distribusi Kelas A Sangat Terbatas
* Hanya beberapa provinsi yang memiliki rumah sakit kelas A dalam jumlah signifikan:
DKI Jakarta, Jawa Barat, Jawa Tengah, dan Jawa Timur
* Banyak provinsi sama sekali tidak memiliki rumah sakit kelas A, terutama di wilayah timur seperti: Papua, Papua Selatan, Papua Tengah, Papua Pegunungan, dan Maluku Utara
* Insight penting: Fitur provinsi sangat penting dalam mendeteksi kemungkinan kelas A — provinsi di luar Pulau Jawa sangat kecil peluangnya.

3. Kelas D Menjadi Penopang di Daerah Kurang Berkembang
* Kelas D cukup dominan di wilayah seperti:
Papua, Nusa Tenggara Timur, Maluku, Kalimantan Barat, dan Sulawesi Tenggara
* Biasanya mewakili rumah sakit kecil atau daerah terpencil.
* Dalam klasifikasi, provinsi-provinsi ini dapat menjadi indikator kuat untuk prediksi kelas D.

4. Kelas B Cenderung Menengah ke Atas dan Terpusat
* Kelas B ditemukan cukup banyak di: DKI Jakarta, Jawa Timur, Jawa Tengah, dan Jawa Barat.
* Juga muncul dalam jumlah kecil di provinsi urban lainnya seperti:
Sumatera Utara, Riau, Sulawesi Selatan.
* Insight penting: Provinsi besar di luar Jawa juga tidak bisa diabaikan sepenuhnya untuk kelas B.
"""

sns.pairplot(nel_clean, diag_kind = 'kde')

# Heatmap korelasi fitur numerik
plt.figure(figsize=(12, 10))
sns.heatmap(nel_clean[numerik].corr(), annot=True, cmap='coolwarm')
plt.title('Heatmap Korelasi Antar Fitur Numerik')
plt.show()

"""## Insight Korelasi Antar Fitur Numerik Rumah Sakit
Heatmap ini menunjukkan hubungan linear antar fitur numerik dalam dataset, termasuk terhadap target klasifikasi_kemiskinan. Nilai korelasi berkisar antara -1 sampai 1:
* 1 = hubungan positif sempurna
* -1 = hubungan negatif sempurna
* 0 = tidak ada hubungan linear

| Pasangan Fitur                                  | Korelasi  | Interpretasi                                                                                                                                                                                                                       |
| ----------------------------------------------- | --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **total\_tempat\_tidur & total\_tenaga\_kerja** | **+0.67** | Korelasi **cukup kuat positif**. Rumah sakit dengan lebih banyak tempat tidur cenderung memiliki lebih banyak tenaga kerja. Hal ini **masuk akal operasional**, karena kapasitas lebih besar butuh SDM lebih banyak.               |
| **total\_tempat\_tidur & total\_layanan**       | **+0.56** | Korelasi **sedang positif**. Artinya makin banyak tempat tidur, layanan medis yang tersedia juga cenderung meningkat. Menunjukkan **ekspansi fasilitas** beriringan dengan peningkatan layanan.                                    |
| **total\_tenaga\_kerja & total\_layanan**       | **+0.50** | Korelasi **cukup positif**, meskipun lebih rendah dari yang lain. Bisa diartikan bahwa meskipun jumlah layanan bertambah, **tidak selalu secara proporsional menambah tenaga kerja** (mungkin karena efisiensi atau spesialisasi). |

# **Data Preparation**
"""

#label encode kelas

# Inisialisasi objek LabelEncoder
label_encoder = LabelEncoder()

# Terapkan encoding pada kolom 'kelas'
nel_clean['kelas'] = label_encoder.fit_transform(nel_clean['kelas'])

# Cek hasil encode
print(nel_clean['kelas'].value_counts())
print(label_encoder.classes_)  # Menunjukkan urutan label asli

"""Melakukan teknik label encode pada kolom kelas"""

#Menghapus kolom provinsi, kab, jenis, status_blu, kepemilikan
nel_clean = nel_clean.drop(columns=['propinsi', 'kab', 'jenis', 'status_blu', 'kepemilikan'])
nel_clean.columns

# Pisahkan kolom target klasifikasi
X= nel_clean.drop(columns=['kelas'])
y= nel_clean[['kelas']]

# Split data train dan test dengan rasio 80:20
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42, stratify=y)

"""Melakukan teknik split data yaitu train dan test dengan rasio 80:20"""

# Normalisasi menggunakan standard scaler
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

"""Melakukan normalisasi dengan menggunakan metode standard scaler agar data yang digunakan tidak memiliki penyimpangan yang besar.

![download (2).png](data:image/png;base64,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sGTJEmbPnq3dDTULtI8dO7ZFDnPStE9nyMTVvRCPiyay5FhmUmxeAH9qsFNH9uko4o6c4wwOGOhHwGB/One0wrfxC22Iv+DCBJUXX3wRV1dXvvjiC+OKLJebVp+Tk0NaWhrAFVeCKC0tZfbs2cap5N26deP111+HmtUh7Ozs+Oabb0hKSmL69Om1ppxXVlYSFxdHaWkpU6ZMoWvXrg1eveWvcHV15auvvuLf//43Bw4cYOPGjUyseczRBenp6Vcc4pw6dSoGg4E33niD9PR0nn/++TrX+S48qqhfv3488MADzJkzp0Grt1zJwIEDWbhwIXPmzCEnJ4ePPvqI9evX16o5ffo0eXl5tfZdDcnJyUyZMqXBK+fs3r2bvLw8hg8fzuOPPw41w7X1mT17NhYWFnz44YfGx+DMmzePH3/8sVbdiRMnSE1NJTAwkEWLFtG3b99LDtfZ29sbH+h64TFPTk5ODVodpj7jx4+nvLycZ555hqysLObOncuSJUtq1Rw9epTU1FQ6derEggULmDNnzhVXb7mwju6Fe/7CwsIuudyalp2dHZ999hmRkZHs3LmTbdu21fmdpuY1oqKiKCsr49Zbb215M0+1XcBrJ1ul7P9IvTWrl3Go855PflW70+oOnTRI9h61MfIuNbmtt7K07ap8enyo3tn8hzpTz3CFaDp79+5VkZGR6sUXX1QeHh61hl+0W9u2bVVkZKSKjIxUJ06c0J5KqZoHXd577711jh0+fHitut27d6t77rmnTt3F2+233662bNmi4uPj1bPPPqtatWqlJk+eXGfV+6s11HnBd999pyIjI40P2714Cw0NNf4MgoODFfUMdSqlVFRUlJozZ45ycHCoc44L24033qi+//57lZ+fr95++20VGBioevfurX744Yda52rMUKdSSuXm5qq5c+eqyMhI1b9//zqvO2rUKBUZGakeffRR41MhrsZQZ2O3GTNmqMjISPXzzz9rT1mvI0eOGH/2F4ak69t69uypPvvsM2UwXPlpLzqdTr388suqdevWasKECWrt2rXakjouNdSplFLnzp1TL730kvLy8qrzdV3Y+vTpoxYtWqT0er36+OOPVffu3VWbNm3UokWLap1r79696v77769z/ODBg2vVXW6o84Iff/xRRUZG1vveBJStra169NFHVWRkpNq8ebP2cKWaeajTIjKynocpXRP26HNySDgVy459Z9DjSe8h4wjv2A6/Vo3peBqAQs7sWM13K7aw6kgBFgH9GHb/fTw8vD3B7vV/GhNNw8/Pj6FDhzJgwACSk5Np3bo1oaGh9W7Dhw/ntddeY+jQoXh7e2tPBYC/vz+BgYGkpKTUOrZXr1617ssLCAigQ4cO6HS6Oq9zYXvqqacYMmQIbm5u9O3bl3PnzlFUVERAQECtWX8JCQnY29sTERHB0KFDjfvrk56eTkVFBWFhYYwbN67e3kDXrl0ZOnQoAQEBpKen1/qabrrpJv7zn/8wdOhQ8vLycHJyonfv3gwePLjWOTw8POjVqxdJSUm0bdu2zvcWGhrK9OnTueOOO7C1tWXAgAHk5ORQVFSEg4NDrWfy6XQ6qqur6dq1K2PHjr3sGpzUfMofOHAgQ4cOxdzcHIPBUOt1Z86cyezZs+nWrRtJSUl06NCB4cOHX7K3dSUXhqq139+VtpdffpkpU6Y0+HVbt27N0KFDGTp0KDqdDg8PjzrnDA0NZcqUKTz88MMNWgLRycmJIUOGoNPpmDp1KjfddJO2pI6kpCQsLS3p0aNHnRvcXVxcjMP33t7edb620NBQ7rjjDh544AHMzc2JiIigrKyMiooKzMzMGDlypPFcfn5+BAUFkZycXOv4Xr16MWLECGNdZmYmJSUldOrUiYkTJ9Y7atO5c2eGDh1a73szNDSUbt268cYbbzB+/PhL3sZx4YHIoaGhjBkz5rI331dVVREbG4ufnx+DBw+ud5ZuY5ipqzGXt6HSD7Fj2Ve88OI3HChvx/DH/8Vj941kbCNWblGGUqqKDvLG7Af49Pt4Mn27EjDsHyz//Gm62FnT8teGF0II0ZyacHIL4OlFWN+OPDSyDTZmsZylhCtf0q+tMjeX+LmRLFsdTyaB9L75Phb/36N0t7W6KtPzhRBCXN+aNvgsvLAI6IP36BsZbtBTuHwfe48kclxbdwlpcUf48f+e4da3txNbFspNzz3Gi49OoYebEzZmZlx5IEIIIYSpa9rgwxZbt2A6DLmFm6f0wyP1LKd+O8COwwlkXli/s145pJzeyobvviXytQ1EBQxk3L+fYMad4xnUMQAnkNATQgjRIE04ueU8Kys7nBw9cfOxpiIvjT1bjlFYpQcPV1rZW6IqK7EwM0OpCgoKdGRlpRBzZDu716xi+erfOWg3ivsfnsHD02+iX7Dvn7oRQgghhOlq2sktGglbP2fp/I/4eN1ZMobcz9xXJhJWWUV7bx9sHas4k7iO+PgkVsxeRDo96DDtPvrdehPPjg3ExqqJO6tCCCGuC80afFXlJVQmniU1OYqT1VFsWLuCM9+c5EApFAUFEjpyBM7tWvNk6BR6hLTBw8cSa1tbHG0tacDMYiGEEKKOZg0+AMrL0VcUUaAvJD09jcK0IorLq1AODjh6eeHo6IiPkw+tHG25wu1GQgghxBU1f/AJIYQQTUgulAkhhDApEnxCCCFMigSfEEIIkyLBJ4QQwqRI8AkhhDApEnxCCCFMigSfEEIIkyLBJ4QQwqRI8AkhhDApEnxCCCFMigSfEEIIkyLBJ4QQwqRI8AkhhDApEnxCCCFMigSfEEIIkyLBJ4QQwqRI8AkhhDApEnxCCCFMigSfEEIIkyLBJ4QQwqRI8AkhhDApEnxCCCFMigSfEEIIkyLBJ4QQwqT8P//GnKLLJxJDAAAAAElFTkSuQmCC)

Metode ini bekerja dengan cara menghitung rata-rata dan standar deviasi dari data, kemudian membagi setiap nilai data dengan standar deviasi tersebut.
"""

# Cek distribusi sebelum SMOTE
print("Distribusi sebelum SMOTE:", Counter(y_train['kelas']))

# Inisialisasi SMOTE
smote = SMOTE(random_state=42)

# Terapkan SMOTE ke data train yang sudah dinormalisasi
X_train_smote, y_train_smote = smote.fit_resample(X_train_scaled, y_train['kelas'])

# Cek distribusi setelah SMOTE
print("Distribusi setelah SMOTE:", Counter(y_train_smote))

"""Saya menggunakan teknik Oversampling SMOTE untuk menangani permasalahan ketidakseimbangan kelas pada data latih.

SMOTE (Synthetic Minority Over-sampling Technique) merupakan metode yang digunakan ketika satu kelas (biasanya disebut kelas minoritas) memiliki jumlah sampel yang jauh lebih sedikit dibandingkan kelas lainnya (kelas mayoritas). Tujuan utama dari SMOTE adalah untuk menyeimbangkan distribusi kelas dengan menciptakan data sintetis baru untuk kelas minoritas, bukan hanya dengan menduplikasi data yang sudah ada.

Cara kerja SMOTE secara sederhana dapat dijelaskan sebagai berikut:

1. Mencari Tetangga Terdekat: Untuk setiap sampel di kelas minoritas, SMOTE akan mencari beberapa sampel lain dalam kelas yang sama yang memiliki kemiripan tertinggi (misalnya dari segi fitur atau nilai atribut).

2. Membuat Sampel Sintetis: Alih-alih menduplikasi sampel yang ada, SMOTE akan menghasilkan data baru yang berada di antara dua sampel yang mirip. Data sintetis ini dibuat dengan mengambil nilai-nilai di titik tengah antara dua sampel yang sudah ada.

3. Menambahkan Sampel Baru: Data baru hasil interpolasi ini kemudian ditambahkan ke dalam data latih, sehingga jumlah data pada kelas minoritas meningkat dan menjadi lebih seimbang dengan kelas mayoritas.

Melalui proses ini, SMOTE membantu model machine learning untuk belajar dari distribusi kelas yang lebih adil dan mengurangi bias terhadap kelas mayoritas.

# **Model Development**
"""

# Siapkan dataframe untuk menyimpan performa model
models = pd.DataFrame(index=['accuracy', 'precision', 'recall', 'f1_score'],
                      columns=['KNN', 'DecisionTree', 'RandomForest'], dtype='float')

"""# **K-Nearest Neighbour**"""

# train model KNN
knn = KNeighborsClassifier(n_neighbors=5)
knn.fit(X_train_smote, y_train_smote)

y_train_pred_knn = knn.predict(X_train_smote)
y_test_pred_knn  = knn.predict(X_test_scaled)

# Performa model pada test set
accuracy_knn  = accuracy_score(y_test, y_test_pred_knn)
precision_knn = precision_score(y_test, y_test_pred_knn, average='weighted')
recall_knn    = recall_score(y_test, y_test_pred_knn, average='weighted')
f1_score_knn  = f1_score(y_test, y_test_pred_knn, average='weighted')

# Simpan ke dataframe
models.loc['accuracy', 'KNN']   = accuracy_knn
models.loc['precision', 'KNN'] = precision_knn
models.loc['recall', 'KNN']    = recall_knn
models.loc['f1_score', 'KNN']  = f1_score_knn

"""Model pertama yang saya gunakan adalah algoritma K-Nearest Neighbors (KNN), yaitu metode klasifikasi yang memprediksi label suatu data baru berdasarkan label dari K data terdekatnya dalam ruang fitur. Kedekatan antar data biasanya diukur menggunakan metrik jarak, seperti jarak Euclidean.

Cara kerja KNN dapat dijelaskan sebagai berikut:

1. Menentukan Nilai K: Tentukan jumlah tetangga terdekat yang akan digunakan dalam proses klasifikasi. Pada kasus ini, saya menggunakan nilai K = 5.

2. Menghitung Jarak: Hitung jarak antara data baru dengan seluruh data dalam dataset pelatihan menggunakan metrik jarak tertentu.

3. Menentukan K Tetangga Terdekat: Identifikasi K data pelatihan yang memiliki jarak paling dekat dengan data baru tersebut.

4. Melakukan Klasifikasi: Dari K tetangga terdekat, hitung frekuensi kemunculan setiap label kelas. Kelas yang paling sering muncul di antara tetangga tersebut akan menjadi prediksi label untuk data baru.

# **Decision Tree**
"""

# train model Decision Tree
dtree = DecisionTreeClassifier(random_state=42, max_depth=3)
dtree.fit(X_train_smote, y_train_smote)

y_train_pred_dt = dtree.predict(X_train_smote)
y_test_pred_dt  = dtree.predict(X_test_scaled)

# Performa model pada test set
accuracy_dt  = accuracy_score(y_test, y_test_pred_dt)
precision_dt = precision_score(y_test, y_test_pred_dt, average='weighted')
recall_dt    = recall_score(y_test, y_test_pred_dt, average='weighted')
f1_score_dt  = f1_score(y_test, y_test_pred_dt, average='weighted')

# Simpan ke dataframe
models.loc['accuracy', 'DecisionTree']   = accuracy_dt
models.loc['precision', 'DecisionTree']  = precision_dt
models.loc['recall', 'DecisionTree']     = recall_dt
models.loc['f1_score', 'DecisionTree']   = f1_score_dt

"""Selanjutnya, saya menggunakan algoritma Decision Tree, yaitu metode pembelajaran terawasi (supervised learning) yang dapat digunakan untuk menyelesaikan masalah klasifikasi maupun regresi. Algoritma ini membangun struktur menyerupai pohon, di mana:

* Setiap node internal mewakili suatu fitur atau atribut dari data,

* Setiap cabang mewakili kondisi atau aturan pengambilan keputusan berdasarkan nilai fitur tersebut,

* Dan setiap node daun (leaf) menunjukkan hasil akhir berupa label kelas atau nilai prediksi.

Tujuan utama dari Decision Tree adalah membentuk rangkaian aturan keputusan secara bertahap dalam bentuk pernyataan "jika-maka" (if-then), yang dapat digunakan untuk mengklasifikasikan data baru atau memprediksi nilainya berdasarkan atribut yang dimilikinya.

# **Random Forest**
"""

# train model Random Forest
rf = RandomForestClassifier(random_state=42, max_depth=3)
rf.fit(X_train_smote, y_train_smote)

y_train_pred_rf = rf.predict(X_train_smote)
y_test_pred_rf  = rf.predict(X_test_scaled)

# Performa model pada test set
accuracy_rf  = accuracy_score(y_test, y_test_pred_rf)
precison_rf = precision_score(y_test, y_test_pred_rf, average='weighted')
recall_rf = recall_score(y_test, y_test_pred_rf, average='weighted')
f1_score_rf  = f1_score(y_test, y_test_pred_rf, average='weighted')

# Simpan ke dataframe
models.loc['accuracy', 'RandomForest']   = accuracy_rf
models.loc['precision', 'RandomForest'] = precison_rf
models.loc['recall', 'RandomForest']    = recall_rf
models.loc['f1_score', 'RandomForest'] = f1_score_rf

"""Terakhir, saya menggunakan algoritma Random Forest, sebuah metode supervised learning yang termasuk dalam kategori ensemble learning. Berbeda dengan pendekatan yang hanya mengandalkan satu model, Random Forest membangun sejumlah pohon keputusan (Decision Tree) secara independen. Setelah semua pohon terbentuk, hasil prediksi dari masing-masing pohon kemudian digabungkan untuk menghasilkan prediksi akhir.

Konsep dasar dari Random Forest adalah bahwa gabungan dari banyak model sederhana (dalam hal ini, pohon keputusan yang relatif lemah) dapat membentuk sebuah model yang lebih kuat, stabil, dan akurat. Pendekatan ini membantu mengurangi risiko overfitting yang umum terjadi pada model Decision Tree tunggal.

# **Evaluasi Models**
"""

print(models)

"""Insight Evaluasi Model

1. Model dengan Akurasi Tertinggi adalah K-Nearest Neighbors (KNN) dengan akurasi 69,89%, diikuti oleh Decision Tree dan Random Forest. Ini menunjukkan bahwa KNN lebih konsisten dalam memprediksi kelas rumah sakit secara keseluruhan.

2. Precision Tertinggi justru dimiliki oleh Decision Tree (83,96%), menunjukkan bahwa model ini lebih andal dalam menghindari prediksi yang salah untuk kelas minoritas — meskipun akurasinya lebih rendah. Hal ini bisa menunjukkan ketimpangan dalam distribusi kelas, di mana model Decision Tree lebih konservatif tetapi “tepat sasaran” ketika memberikan prediksi positif.

3. Recall dan F1-Score mengikuti tren yang sama dengan akurasi:

* Recall dan F1-Score tertinggi dimiliki oleh KNN, memperkuat bahwa model ini paling seimbang antara ketepatan dan kelengkapan dalam prediksi.

* Random Forest menunjukkan performa terendah di seluruh metrik, mengindikasikan bahwa konfigurasi atau tuning-nya mungkin belum optimal untuk dataset ini.

4. Kesimpulan Model Terbaik:

* KNN adalah model terbaik secara keseluruhan, karena memberikan keseimbangan terbaik antara accuracy, recall, dan f1-score.

* Decision Tree bisa dipertimbangkan apabila fokus analisis lebih berat pada precision (misalnya, jika salah klasifikasi lebih berdampak daripada tidak mengklasifikasikan).

* Random Forest memerlukan tuning lebih lanjut atau bisa digantikan, karena saat ini memiliki performa paling rendah.
"""

# Confusion matrix KNN
cm_knn = confusion_matrix(y_test, y_test_pred_knn)

# Visualisasi confusion matrix
plt.figure(figsize=(8,6))
sns.heatmap(cm_knn, annot=True, fmt='d', cmap='Blues',
            xticklabels=knn.classes_, yticklabels=knn.classes_)
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.title('Confusion Matrix KNN')
plt.show()

# Confussion matrix Decision tree
cm_dt = confusion_matrix(y_test, y_test_pred_dt)

# Visualisasi confusion matrix
plt.figure(figsize=(8,6))
sns.heatmap(cm_dt, annot=True, fmt='d', cmap='Blues',
            xticklabels=dtree.classes_, yticklabels=dtree.classes_)
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.title('Confusion Matrix Decision Tree')
plt.show()

# Confussion matrix Random forest
cm_rf = confusion_matrix(y_test, y_test_pred_rf)

# Visualisasi confusion matrix
plt.figure(figsize=(8,6))
sns.heatmap(cm_rf, annot=True, fmt='d', cmap='Blues',
            xticklabels=rf.classes_, yticklabels=rf.classes_)
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.title('Confusion Matrix Random Forest')
plt.show()

"""Kesimpulan:
* KNN adalah model terbaik dalam konteks klasifikasi tipe rumah sakit, karena memberikan performa menyeluruh yang paling stabil dan seimbang.

* Decision Tree bisa dipertimbangkan jika fokus utama adalah menghindari false positive, misalnya untuk kebijakan yang hanya boleh diterapkan jika prediksi sangat yakin.

* Random Forest memerlukan penyempurnaan, seperti hyperparameter tuning atau peningkatan kualitas data, sebelum layak digunakan sebagai model produksi.
"""